#include <iostream>
#include "../sylvtools.cpp"

//goto main function //last

//bst_sort
typedef struct node{
	//int subtree_count;//augmenting bst can add additional feature
	int value;
	struct node* leftchild=nullptr;
	struct node* rightchild=nullptr;
	struct node* parent=nullptr;
	node(int value){this->value = value;}
	node(){this->value = -9999;}
}node;
typedef struct bst{
	node* head;
	int size;
	int inorder_index;

	
	bst(int value){
		this -> head = new node(value);
		this -> size = 1;
	}


	void insert(int value){
		node* node_ptr = this -> head;
		while(true)
			if(node_ptr -> value >= value){
				//cout << "arg " << node_ptr-> value << " <= " << value << endl;
				//cout << "adding " << value << " to left" << endl;
				if( node_ptr -> leftchild == nullptr) {
					node_ptr -> leftchild = new node(value);
					node_ptr -> leftchild -> parent = node_ptr;
					this -> size++;
					break;
				}
				node_ptr = node_ptr -> leftchild;
			}
			else{
				//cout << "arg " << node_ptr-> value << " > " << value << endl;
				//cout << "adding " << value << " to rigth" << endl;
				if( node_ptr -> rightchild == nullptr) {
					node_ptr -> rightchild = new node(value);
					node_ptr -> rightchild -> parent = node_ptr;
					this -> size++;
					break;
				}
				node_ptr = node_ptr -> rightchild;
			}
	}
	void inorder_traverse(int* a, node* n){
		if(n-> leftchild != nullptr)inorder_traverse(a,n->leftchild);
		a[this -> inorder_index++]=n->value;
		if(n-> rightchild != nullptr)inorder_traverse(a,n->rightchild);
	}
	void get_sorted_array(int* a){
		this -> inorder_index = 0;
		inorder_traverse(a,this->head);
	}
	void print_node(node* ptr){
		if(ptr -> leftchild == nullptr &&
				ptr -> rightchild == nullptr)return;
		cout << "|| " << ptr -> value << " : ";
		if(ptr->leftchild != nullptr){ 
			cout << ptr-> leftchild-> value ;
		}
		cout<< " _ ";
		if(ptr->rightchild != nullptr){
			cout << ptr-> rightchild-> value ;
		}
		cout << " ||" << endl;
		if(ptr->leftchild != nullptr)print_node(ptr->leftchild);
		if(ptr->rightchild != nullptr)print_node(ptr->rightchild);
	}
	void print_tree(){
		cout << "Tree of size : " << this->size << endl;
		print_node(this->head);
		cout <<endl;
	}
}bst;

//heap_sort
class MaxHeap{
	private:
		int n; //size of current heap
		int N; //max size of heap array a will be helpful in insertion
		int* a; //pointer to array

	public:
		//provided array, current size n, size of array
		MaxHeap(int* a,int n,int N){
			//cout << "new heap with size " << n << "/" << N << endl;
			this -> N = N;
			if(N<n){
				cout << "ERROR:size of array cannot be SMALLER than current size"<<endl;
				this-> N=n;
			}
			this -> a = a;
			this -> n = n;
			firstHeapify();
		}
		MaxHeap(int* a,int n){
			this -> a = a;
			this -> n = n;
			firstHeapify();
		}


		int max(){
			return a[0];
		}
		int extractMax(){
			if(n<0){return -99999;}
			int temp;
			temp=a[0];
			a[0]=a[n-1];
			n--;
			maxHeapifyDown(0);

			//printHeap();
			return temp;
		}
			

		void firstHeapify(){
			for(int i=(n-1)/2;i>=0;i--)maxHeapify(i);
		}
		int maxHeapify(int index){
			//cout <<"Heapifying ++++ " << index <<":"<< a[index] << endl;
			if(index>=n || index<0)return -1;
			int leftChildIndex = (2*index)+1;
			if(leftChildIndex>=n)return -1;
			int swapIndex,temp;

			if(n<2){
				if(a[index]<a[leftChildIndex])swapIndex=leftChildIndex;
				else return -1;
			}else{
				if(a[index]>a[leftChildIndex]&&a[index]>a[leftChildIndex+1])return -1;
				else if(a[leftChildIndex]>=a[leftChildIndex+1])swapIndex=leftChildIndex;
				else swapIndex=leftChildIndex+1;
			}
			temp=a[index];
			a[index]=a[swapIndex];
			a[swapIndex]=temp;

			//printHeap();

			return swapIndex;
		}
		void maxHeapifyDown(int index){
			int swapIndex=maxHeapify(index);
			if(swapIndex<0)return;
			maxHeapifyDown(swapIndex);
		}

		//dont need it.....yet
		/*void MaxHeapifyUp(int index){
		 *	if(index<=0)return;
		 *	maxHeapify(index);
		 *	if(index%2==0)//its a right child;
		 *		index=(index-2)/2;//parent
		 *		else
		 *			index/=2;//parent
		 *	MaxHeapifyUp(index);
		 *}
		 */

		void printchildren(int index){
			if(index>=n)return;
			int leftChildIndex = (2*index)+1;
			if(leftChildIndex>=n)return;
			cout << "~" << index << " -> " << a[index] ;
			if(leftChildIndex < n)cout << " : " << a[leftChildIndex];
			if(leftChildIndex+1 < n)cout << " _ " << a[leftChildIndex+1];
			printchildren(leftChildIndex);
			printchildren(leftChildIndex+1);
		}
		void printHeap(){
			cout << endl;
			for(int i=0;i<n;i++)cout<< "| " <<a[i] << " ";
			cout<< "|\nTree______" <<endl;
			printchildren(0);
			cout << endl;
		}
};
void heap_sort(int* a,int n){
	int b[n];
	for(int i=0;i<n;i++)b[i]=a[i];
	MaxHeap h=MaxHeap(b,n);
	for(int i=n-1;i>=0;i--)a[i]=h.extractMax();
}

//insertion_sort
void insertion_sort(int *a, int n){
	int t=0;
	for(int i=1,j=0; i<n; i++){
		j=i;
		t=a[j];
		while(j>0 && a[j-1]>t) a[j--]=a[j-1];
		a[j]=t;
	}
}

//binary_insertion_sort
int binary_search(int start, int end,int* a, int k){
	int m = (start+end)/2;
	//printia("l", a, start,end);
	//cout << start << " and " << end << " = " << m << endl;

	if(start == end) return m;

	if(end-start == 1)return (a[start]>k)?start:end;	

	if(a[m]>k) return binary_search(start,m, a, k);
	else return binary_search(m, end, a, k);
}
void binary_insertion_sort(int *a, int n){
	for(int i=1,j,t,k,rk; i<n; i++){
		j=i;
		k=a[i];
		//cout<<endl;
		//cout << "k=" << k << "start=" << 0 << "end=" << j << endl; 
		//printa("loc_bef",a,j+1);
		rk=binary_search(0,j,a,k);
		// 0 1 4 6 9 2 3 5
		// 0 1 2 3 4 5 6 7
		//cout << j << "j rk" << rk <<endl;
		while(j>rk){
			a[j]=a[j-1];

			j--;
		}
		a[rk]=k;
		//printa("loc_aft",a,i+1);
		//printa("loc_aft",a,n);
	}
}

//merge_sort
void merge(int* a,int s, int e){
	if(s==e){
		return;
	}
	int m = (s+e)/2;
	merge(a,s,m);
	merge(a,m+1,e);

	int lc=m-s+1, rc=e-m, fk;
	int la[lc],ra[rc];
	for(int i=0,fk=s;i<lc;i++)la[i]=a[fk++];
	for(int i=0,fk=m+1;i<rc;i++)ra[i]=a[fk++];

	int rsk=s;
	int lk=0,rk=0;

	while(1){
		if(lk==lc || rk == rc)break;
		if(la[lk]<=ra[rk]) a[rsk++]=la[lk++];
		if(ra[rk]<=la[lk]) a[rsk++]=ra[rk++];
	}
	while(lk<lc)a[rsk++]=la[lk++];
	while(rk<rc)a[rsk++]=ra[rk++];
}
void merge_sort(int* a, int n){
	merge(a,0,n-1);
}

int main(){
	//data
	int a[2000]={991,912,281,431,196,242,211,965,447,254,214,855,390,21,750,572,328,50,968,291,481,470,874,147,432,193,932,249,341,56,324,576,562,305,340,299,141,133,61,52,965,293,344,425,448,134,142,631,713,683,755,552,912,819,181,203,624,184,715,21,719,418,160,151,506,847,815,420,500,985,167,545,480,197,131,667,918,832,135,199,862,743,855,267,690,931,821,222,289,302,846,821,838,562,6,664,590,492,593,355,356,163,795,43,988,47,359,192,220,628,859,770,179,670,410,542,897,777,645,80,893,930,983,14,648,955,306,225,487,128,981,107,598,503,63,608,220,169,560,896,883,600,460,604,1,758,805,618,640,307,322,391,334,107,702,214,872,425,986,409,876,396,658,556,66,875,980,26,269,616,676,440,792,1,679,256,968,857,841,33,897,733,451,411,350,563,412,287,649,18,234,959,739,324,983,306,888,575,104,235,98,311,73,852,284,279,708,568,422,834,280,286,445,311,471,906,631,707,707,57,319,891,818,204,259,623,796,321,215,89,977,993,454,531,418,152,897,748,189,710,807,200,209,544,750,157,955,173,263,348,146,105,879,952,609,417,446,37,433,986,229,615,779,361,388,582,998,614,546,451,870,394,968,33,134,453,232,552,498,947,946,80,586,500,779,231,656,584,816,315,413,737,473,434,843,425,902,507,647,153,777,554,83,128,138,818,517,697,898,94,812,339,909,477,579,973,149,925,824,979,189,509,767,534,170,643,992,978,473,736,28,643,123,721,75,51,763,532,277,768,702,406,222,289,822,15,175,485,101,214,437,311,768,168,39,841,241,588,484,468,415,534,264,894,847,378,752,0,213,926,943,358,234,147,531,106,369,247,256,603,93,505,60,403,738,851,89,92,220,200,14,716,283,528,634,525,547,33,967,984,104,481,994,312,113,782,409,583,765,908,790,556,193,751,475,35,131,939,581,845,694,762,200,419,717,579,439,553,672,891,456,567,604,280,639,474,181,69,431,153,55,387,599,343,238,508,602,795,908,223,242,585,210,92,903,65,708,75,343,223,874,648,858,996,491,16,105,967,579,53,520,965,457,479,289,526,869,734,56,825,86,884,877,266,410,462,366,605,911,693,349,663,804,285,997,579,618,149,736,946,676,798,21,604,106,214,139,628,612,614,75,836,880,720,974,317,564,706,996,167,754,472,87,622,565,844,5,280,67,959,850,890,6,773,132,836,737,403,36,659,438,414,654,177,621,943,996,109,455,966,410,672,68,307,238,281,466,734,515,830,161,573,825,423,436,726,969,985,842,262,537,706,71,194,826,422,870,930,946,714,414,343,210,48,201,161,355,70,169,740,42,709,585,146,4,96,992,547,805,476,696,269,886,427,909,256,670,546,219,735,108,140,9,357,439,924,403,800,408,183,935,30,862,478,321,791,966,693,718,127,599,967,179,234,521,11,733,909,453,110,119,813,219,686,144,347,461,381,847,906,90,427,445,602,614,211,111,951,452,192,571,311,86,846,35,685,251,340,732,803,857,708,360,53,237,225,581,484,340,798,181,820,587,75,16,162,726,677,41,206,777,937,652,646,178,422,140,264,43,31,69,475,860,768,237,750,271,301,197,538,649,383,905,497,634,347,20,558,632,960,82,25,681,108,378,43,505,36,688,371,11,595,580,411,406,355,927,247,788,874,439,345,629,245,87,831,29,843,378,338,893,435,463,649,557,327,917,815,116,671,917,273,699,899,849,805,727,506,797,42,
		825,549,605,486,106,724,919,119,583,751,296,811,1,819,364,449,371,338,488,336,806,675,525,910,99,250,574,383,698,483,3,857,910,590,143,520,41,254,137,653,994,118,297,211,708,664,558,601,822,627,560,499,486,614,551,842,735,964,734,895,880,857,49,623,70,496,167,509,877,561,635,892,816,897,892,176,834,409,366,202,108,536,982,257,107,280,36,891,439,600,917,393,238,199,803,28,569,900,931,467,373,109,705,181,169,343,827,987,651,450,958,595,802,942,36,282,750,909,215,574,347,697,246,780,180,602,71,979,158,854,579,78,18,290,898,484,249,606,465,276,356,735,312,637,225,309,380,144,171,992,412,444,34,437,325,653,479,989,467,399,948,368,964,626,326,252,704,565,723,920,156,534,87,791,390,853,194,790,532,487,748,734,203,757,76,142,405,742,98,514,651,450,114,963,750,766,12,642,318,633,294,501,576,315,941,825,686,458,270,128,216,88,349,275,837,603,361,534,926,717,728,123,201,521,374,384,185,620,709,735,
		693,661,87,2,264,180,928,762,271,691,153,238,499,249,904,3,992,920,105,576,873,967,533,757,615,741,573,113,8,59,339,805,457,317,148,391,200,932,109,697,399,126,595,50,419,866,999,427,646,768,41,552,316,565,186,663,163,669,659,467,725,41,316,692,978,678,511,854,85,642,212,827,483,882,550,171,250,308,600,930,688,673,935,288,84,451,75,224,392,679,427,447,174,578,219,710,406,465,561,861,924,599,267,802,632,398,77,657,150,357,270,142,640,11,42,323,478,42,30,534,767,461,780,978,239,295,954,198,479,735,627,189,719,456,329,765,40,473,924,559,707,84,689,308,253,393,292,735,727,350,146,310,317,350,470,440,397,562,339,534,596,818,784,130,983,394,18,798,367,491,250,145,460,552,603,715,509,506,761,540,670,665,137,882,414,755,796,577,380,668,603,777,616,419,94,407,585,736,727,153,737,233,213,991,152,279,267,394,280,625,144,545,271,134,833,986,245,979,244,139,486,696,358,115,76,507,602,918,784,73,76,881,242,258,951,331,429,679,444,798,792,345,221,316,727,747,492,798,514,214,43,709,457,91,581,507,957,437,221,769,698,964,276,964,183,702,418,469,80,42,257,11,511,926,702,311,251,691,92,565,317,320,944,967,505,12,66,23,701,396,388,716,636,4,507,491,735,789,535,405,862,494,642,883,349,390,291,200,421,277,363,84,786,973,985,796,207,488,312,419,51,370,996,356,306,350,315,936,662,198,83,892,424,204,749,422,948,753,42,43,852,660,253,834,458,858,423,40,860,476,643,565,369,796,968,999,646,472,48,47,776,243,614,789,966,579,613,794,36,690,83,207,376,431,173,629,222,111,104,821,526,889,974,177,271,242,257,800,679,778,900,549,966,865,230,789,947,907,407,277,399,380,361,596,712,155,788,519,954,624,364,53,442,6,636,875,387,677,906,355,819,905,585,154,93,390,546,795,550,994,903,414,666,651,26,345,652,119,122,75,155,833,69,330,230,576,633,215,365,264,322,653,797,252,632,619,382,478,570,930,403,562,705,496,299,16,2,850,393,97,528,121,688,31,664,814,136,648,277,592,970,114,278,229,632,419,724,122,193,193,44,452,468,220,915,357,343,824,334,990,792,722,215,305,405,690,359,680,579,699,464,564,614,308,14,918,130,693,604,61,81,903,617,563,429,875,408,323,115,167,237,383,127,537,916,839,616,889,24,506,797,837,56,67,642,42,509,24,388,628,535,940,366,437,232,398,852,868,982,131,244,688,94,412,316,884,670,534,933,35,115,250,592,610,60,85,213,657,961,9,463,379,483,733,21,770,929,722,825,866,228,587,676,920,599,251,80,96,451,224,329,577,386,790,114,283,127,157,102,901,154,914,860,513,126,232,136,910,719,712,638,341,528,574,316,866,190,956,7,487,320,532,95,382,672,121,501,420,863,827,365,283,819,416,843,507,917,153,455,171,481,616,255,166,528,347,665,137,279,427,194,99,786,301,739,864,76,701,947,181,874,891,229,268,422,992,905,589,198,714,729,505,273,879,91,632,543,451,427,621,520,970,369,640,611,592,669,691,559,363,62,25,226,973,325,350,0,13,824,153,93,440,12,501,640,992,113,98,793,996,777,893,884,366,791,361,475,79,173,604,669,429,861,722,23,963,690,46,505,380,678,125,734,876,664,600,40,355,710,152,646,672,711,724,104,730,326,495,241,394,784,539,406,964,923,793,425,790,965,849,969,586,331
			,159,735,141,971,785,937,181,498,393,905,227,94,595,348,207,325,296,130,824,574,984,649,915,500,955,467,669,407,923,970,187,180,606,782,882,897,389,378,624,630,468,539,274,466,76,216,824,853,432,999,408,494,649,471,472,396,741,178,973,959,915,474,640,354,396,657,453,688,975,2,399,203,576,709,269,592,184,719,474,993,24,120,968,99,779,548,525,256,327,152,516,951,485,231,847,477,900,191,15,698,713,653,861,208,368,314,179,329,392,416,868,80,339,35,207,6,334,382,979,523,246,930,472,970,399,253,677,306,60,790,836,878,245,44,743,752,657,71,197,782,740,393,476,734,214,294,461,185,607,719,786,658,864,669,422,411,830,954,414,963,748,241,550,835,18,762,435,298,665,356,160,204,198,444,720,6,300,378,254,613,709,78,391,240,94,511,523,29,528,792,566,740,393,744,867,736,781,170,477,224,557,955,657,774,853,564,11,588,84,662,297,700,95,674,693,426,236,784,704,272,954,471,778,935,196,665,134
	};

	int b[500]={
		302,799,673,329,766,415,49,165,879,597,256,80,125,934,208,609,829,365,882,809,16,313,671,773,305,823,779,623,222,227,193,336,894,360,413,327,37,144,519,502,540,399,558,514,81,80,692,435,264,815,115,732,755,729,494,855,273,650,690,568,247,258,475,79,305,371,348,456,122,29,70,945,871,693,446,845,85,7,712,196,995,155,870,711,397,790,399,589,544,263,121,553,191,631,0,340,732,207,648,394,61,688,880,835,784,580,923,458,486,743,882,514,838,390,993,855,840,0,589,799,817,464,828,203,7,601,580,904,761,375,413,570,146,455,532,581,410,41,377,146,492,782,525,770,397,35,507,951,360,269,218,818,899,855,935,376,125,350,822,159,327,849,753,851,913,733,994,272,966,793,758,604,902,701,680,307,390,952,682,825,475,45,857,36,154,33,181,899,202,401,470,407,207,108,182,17,723,836,875,159,29,140,929,383,813,199,617,673,704,249,957,571,849,287,397,457,371,503,534,668,808,799,527,67,44,954,989,119,199,960,682,409,304,845,599,675,775,859,453,105,620,173,441,553,174,376,467,236,82,730,229,874,553,746,393,215,395,52,248,239,909,910,537,449,248,576,949,319,477,528,66,628,470,198,277,378,641,932,481,516,378,817,647,421,708,922,837,18,650,607,36,147,567,385,6,486,215,999,623,961,247,135,410,755,865,343,224,208,59,400,29,782,683,718,880,333,869,254,758,818,47,194,338,459,220,881,937,215,596,791,890,490,146,737,947,825,663,839,896,494,619,668,186,121,929,939,767,694,103,2,268,222,27,288,617,923,717,622,289,356,87,163,995,209,108,16,96,381,222,848,838,360,296,462,705,570,816,510,745,307,439,78,34,464,727,784,883,424,942,420,974,78,786,845,282,27,354,434,736,623,603,138,474,597,804,157,529,302,514,390,101,431,45,321,116,405,519,488,512,7,628,888,944,383,108,158,160,152,340,630,684,799,700,59,974,46,286,387,8,497,639,573,156,63,861,819,830,143,30,107,948,987,693,518,90,598,69,659,92,795,959,898,778,750,254,883,888,548,809,370,210,898,704,168,207,200,561,19,372,866,590,170,706,633,220,105,217,84,275,131,716,319,613,752,309,631,522,532,512,458
	};

	int c[200]={
		307,166,207,142,462,507,695,19,347,373,528,958,142,564,63,630,82,244,567,561,372,372,140,620,498,665,75,199,927,938,585,640,39,167,3,916,116,168,212,328,888,214,893,384,185,35,255,614,81,131,431,297,448,789,110,786,984,639,448,403,200,710,701,687,616,248,459,251,296,8,730,688,71,813,311,988,517,575,214,873,116,290,949,547,555,99,807,116,795,431,0,837,521,77,358,895,589,292,884,916,557,897,52,103,427,458,303,956,843,592,360,720,737,230,910,442,466,367,627,950,984,58,345,413,968,723,34,855,145,918,706,299,622,478,353,240,125,439,371,288,332,241,166,156,606,103,360,770,54,593,5,818,880,604,462,797,688,243,878,949,454,198,700,239,85,338,633,702,227,892,93,299,845,735,966,232,822,322,938,675,749,536,934,566,206,741,493,539,957,78,735,686,721,530,852,130,899,581,595,771
	};






























	int start = clock();
	//Resutls  

	//insertion_sort(a,2000);
	//it took 3193ticks, or 0.003193seconds.

	//binary_insertion_sort(a,2000);
	//it took 2916ticks, or 0.002915seconds.
	
	//merge_sort(a,2000);
	//it took 327ticks, or 0.000327seconds.
	
	//heap_sort(a,2000);
	//it took 378ticks, or 0.000378seconds.
	
	//bst_sort
	//bst sor(991);//adding first element as head
	//for(int i=1;i<2000;i++)sor.insert(a[i]);
	//sor.get_sorted_array(a);
	//it took 375ticks, or 0.000375seconds.

	int end = clock();//Now check what amount of ticks we have now.
	//To get the time, just subtract start from end, and divide by CLOCKS_PER_SEC.
	std::cout << "it took " << end - start << "ticks, or " << ((float)end - start)/CLOCKS_PER_SEC << "seconds." << std::endl;


	//print res
	printa("res",a,2000);
	return 0;
}
